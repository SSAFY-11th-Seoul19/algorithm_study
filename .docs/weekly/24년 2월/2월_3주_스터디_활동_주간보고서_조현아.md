## 2월_3주_월

- 구성원
  - 조현아
  - 김현재
  - 조윤정
- 불참자
  - 없음
- 문제
  - [1717 집합의 표현](https://www.acmicpc.net/problem/1717)
- 베스트 코드
  - wr 만들어두고 sysout 쓴 것은 아쉽지만 코드는 유니온 파인드 그자체
  - union 메서드에서 작은 값을 부모로 둔 것이 좋았음
    ```java
    import java.io.BufferedReader;
    import java.io.BufferedWriter;
    import java.io.InputStreamReader;
    import java.io.OutputStreamWriter;
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.LinkedList;
    import java.util.StringTokenizer;
    
    public class Main {
    	static int[] parents;
    	
        public static void main(String[] args) throws Exception {
        	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        	BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out));
        	StringBuilder sb = new StringBuilder();
        	StringTokenizer st = new StringTokenizer(br.readLine());
        	int n = Integer.parseInt(st.nextToken());
        	int m = Integer.parseInt(st.nextToken());
    
        	
        	parents = new int[n + 1];
        	
        	for (int i = 1; i < n + 1; i++) {
        		parents[i] = i;
        	}
        	
        	for (int i = 0; i < m; i ++) {
        		st = new StringTokenizer(br.readLine());
        		int kind = Integer.parseInt(st.nextToken());
        		int a = Integer.parseInt(st.nextToken());
        		int b = Integer.parseInt(st.nextToken());
        		// 합집합을 함
        		if (kind == 0) {
        			union(a, b);
        			continue;
        		}
        		// 같은 집합에 있는지 확인하는 연산
        		if (find(a) == find(b) ) {
        			sb.append("YES").append("\n");
        			continue;
        		}
        		sb.append("NO").append("\n");
        	}
        	System.out.println(sb.toString());
        }
        
        private static int find(int n) {
        	if (parents[n] == n) {
        		return n;
        	}
        	parents[n] = find(parents[n]);
        	return parents[n];
        }
        
        private static void union(int c1, int c2) {
        	int p1 = find(c1);
        	int p2 = find(c2);
        	if (p1 < p2) {
        		parents[p2] = p1;
        		return;
        	}
        	parents[p1] = p2;
        }
    }
    ```
- 문제
  - [17396 백도어](https://www.acmicpc.net/problem/17396)
- 베스트 코드
  - 다익스트라 그자체
    ```java
    import java.io.BufferedReader;
    import java.io.BufferedWriter;
    import java.io.InputStreamReader;
    import java.io.OutputStreamWriter;
    import java.util.ArrayList;
    import java.util.PriorityQueue;
    import java.util.StringTokenizer;
    
    public class Main {
        static final long MAX = 100_000L *100_000L;
        static int N,M;
        static int[] isVisible;
        static long[] times;
        static ArrayList<Edge>[] edges;
    
        static class Edge implements Comparable<Edge>{
            int target;
            long time;
    
            public Edge(int target, long time){
                this.target = target;
                this.time = time;
            }
    
            public int compareTo(Edge o){
                return (int)(this.time - o.time);
            }
        }
    
        public static void main(String[] args) throws Exception{
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    
            StringTokenizer st = new StringTokenizer(br.readLine());
            N = Integer.parseInt(st.nextToken());
            M = Integer.parseInt(st.nextToken());
    
            st = new StringTokenizer(br.readLine());
            isVisible = new int[N];
            times = new long[N];
            edges = new ArrayList[N];
            for(int i=0;i<N;i++){
                isVisible[i] = Integer.parseInt(st.nextToken());
                times[i] = MAX;
                edges[i] = new ArrayList<>();
            }
    
            for(int i=0;i<M;i++){
                st = new StringTokenizer(br.readLine());
                int start = Integer.parseInt(st.nextToken());
                int target = Integer.parseInt(st.nextToken());
                long time = Long.parseLong(st.nextToken());
    
                edges[start].add(new Edge(target,time));
                edges[target].add(new Edge(start,time));
            }
    
            dijkstra(0);
            bw.write((times[N-1]==MAX)?"-1":Long.toString(times[N-1]));
            bw.flush();
    
            br.close();
            bw.close();
        }
    
        public static void dijkstra(int start){
            times[start] = 0;
            PriorityQueue<Edge> pq = new PriorityQueue<>();
            pq.add(new Edge(start,0));
    
            while(!pq.isEmpty()){
                Edge now = pq.poll();
    
                if(now.time > times[now.target]){
                    continue;
                }
    
                for(Edge next:edges[now.target]){
                    if(isVisible[next.target]==1 && next.target!=N-1){
                        continue;
                    }
    
                    if(next.time+now.time >= times[next.target]){
                        continue;
                    }
    
                    times[next.target] = next.time+now.time;
                    pq.add(new Edge(next.target, times[next.target]));
                }
            }
        }
    }
    ```
